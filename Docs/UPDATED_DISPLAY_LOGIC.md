# 更新后的显示逻辑说明

## 概述

本次更新进一步优化了顶层模块的显示逻辑，重新规范化了端口命名，删除了ALU显示相关逻辑，并新增了访问地址显示功能。

## 主要更新内容

### 1. 重新规范化端口命名

#### sccomp模块端口更新

**原端口命名**：
- `Addr_out` - 地址输出
- `Data_out` - 数据输出

**新端口命名**：
- `mem_addr_out` - 内存访问地址输出
- `mem_data_out` - 内存访问数据输出

新的命名更清晰地表明了这些端口的用途，便于理解和维护。

### 2. 智能数据输出逻辑

#### sccomp模块数据输出规则

```verilog
// 根据读写状态输出相应数据
// 如果CPU正在向内存写数据，输出写入的数据
// 如果内存正在被读，输出读到的数据
assign mem_data_out = MemWrite ? dm_din : dm_dout;
```

- **写操作时**：输出CPU要写入内存的数据 (`dm_din`)
- **读操作时**：输出从内存读取的数据 (`dm_dout`)

### 3. 删除ALU显示逻辑

#### 移除的内容

1. **参数定义**：
   - 移除 `ALU_DATA_NUM` 参数

2. **信号定义**：
   - 移除 `alu_addr` 寄存器
   - 移除 `alu_disp_data` 寄存器

3. **控制逻辑**：
   - 移除ALU地址递增/递减逻辑
   - 移除ALU数据选择逻辑

### 4. 新增访问地址显示功能

#### 访问地址显示逻辑

```verilog
// 访问地址数据 - 如果没有发生读取或写入，输出FFFFFFFF
always @(*) begin
    // 检查是否有内存访问（地址不为0或者有实际的内存操作）
    if (mem_addr_out != 32'h0 || mem_data_out != 32'h0) begin
        access_addr_data = mem_addr_out;
    end else begin
        access_addr_data = 32'hFFFFFFFF;  // 没有涉及地址时输出FFFFFFFF
    end
end
```

- **有内存访问时**：显示实际的内存访问地址
- **无内存访问时**：显示 `0xFFFFFFFF` 表示没有涉及地址

### 5. 删除默认显示模式

#### 简化的显示选择逻辑

移除了对 `sw_i[0]` 的依赖，简化了显示模式选择：

```verilog
// 根据开关输入选择显示的数据
always @(*) begin
    if(sw_i[10] == 1'b1) begin
        // 调试显示模式
        display_data = debug_data;
    end else begin
        // 正常显示模式
        case(sw_i[14:11])
            4'b1000: display_data = instr;           // 指令
            4'b0100: display_data = reg_data_from_cpu; // 寄存器数据
            4'b0010: display_data = access_addr_data; // 访问地址数据
            4'b0001: display_data = dmem_data;       // 数据存储器数据
            4'b1001: display_data = PC_out;          // 程序计数器
            default: display_data = PC_out;          // 默认显示PC
        endcase
    end
end
```

## 显示模式详解

### 正常显示模式

使用开关14-11选择显示内容：

| 开关[14:11] | 显示内容       | 说明                               |
| ----------- | -------------- | ---------------------------------- |
| 4'b1000     | 指令           | 当前执行的指令                     |
| 4'b0100     | 寄存器数据     | 根据寄存器地址显示对应寄存器值     |
| 4'b0010     | 访问地址数据   | 内存访问地址，无访问时显示FFFFFFFF |
| 4'b0001     | 数据存储器数据 | 内存访问的实际数据（读/写）        |
| 4'b1001     | 程序计数器     | 当前PC值                           |
| 其他        | 程序计数器     | 默认显示PC                         |

### 调试显示模式 (sw_i[10] = 1)

显示调试数据，不受其他开关影响。

## 控制逻辑

### 统一地址控制

现在只控制两种地址：

- **开关2 (sw_i[2])**: 重置所有地址到0
- **开关3 (sw_i[3])**: 所有地址递增（上升沿触发）
- **开关4 (sw_i[4])**: 所有地址递减（上升沿触发）

### 地址范围

- **寄存器地址**: 5位，范围 0-31
- **存储器地址**: 4位，范围 0-15

### 自动溢出处理

- 寄存器地址：31 → 0，0 → 31
- 存储器地址：15 → 0，0 → 15

## 使用示例

### 监控内存访问

1. 设置开关[14:11] = 4'b0010（访问地址显示模式）
2. 观察显示的地址：
   - 有内存访问时：显示实际访问地址
   - 无内存访问时：显示FFFFFFFF

### 查看内存数据

1. 设置开关[14:11] = 4'b0001（数据存储器显示模式）
2. 观察显示的数据：
   - CPU写内存时：显示写入的数据
   - CPU读内存时：显示读取的数据

### 查看寄存器数据

1. 设置开关[14:11] = 4'b0100（寄存器显示模式）
2. 使用开关3/4切换寄存器地址
3. 观察不同寄存器的值

## 优势

1. **更清晰的命名**：端口命名更直观，易于理解
2. **智能数据显示**：根据读写状态自动显示相应数据
3. **简化的控制逻辑**：移除了复杂的ALU显示逻辑
4. **直观的地址监控**：清楚显示内存访问状态
5. **更简洁的代码**：删除了冗余的显示模式

## 兼容性

- 保持了原有的基本显示功能
- 开关控制方式保持不变
- 七段数码管显示逻辑保持不变
- CPU核心功能不受影响

## 测试建议

1. **内存访问测试**：运行包含load/store指令的程序，观察地址和数据显示
2. **寄存器测试**：切换不同寄存器地址，验证数据正确性
3. **边界测试**：测试地址溢出处理是否正确
4. **显示模式测试**：验证各种显示模式切换是否正常 