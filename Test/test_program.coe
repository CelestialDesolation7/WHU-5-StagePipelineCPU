MEMORY_INITIALIZATION_RADIX=16;
MEMORY_INITIALIZATION_VECTOR=
// ========================================
// RISC-V RV32I Pipeline CPU Test Program
// ========================================
// 测试用例1: 基本算术运算
00000093,  // addi x1, x0, 0    # x1 = 0
00100113,  // addi x2, x0, 1    # x2 = 1
00208193,  // addi x3, x0, 2    # x3 = 2
00310213,  // addi x4, x0, 3    # x4 = 3
00418293,  // addi x5, x0, 4    # x5 = 4

// 测试用例2: 数据冒险测试 (RAW Hazard)
00410133,  // add x2, x2, x4    # x2 = x2 + x4 = 1 + 3 = 4
005181b3,  // add x3, x3, x5    # x3 = x3 + x5 = 2 + 4 = 6
00620233,  // add x4, x4, x6    # x4 = x4 + x6 = 3 + 0 = 3
007282b3,  // add x5, x5, x7    # x5 = x5 + x7 = 4 + 0 = 4

// 测试用例3: Load-Use冒险测试
0000a303,  // lw x6, 0(x1)      # x6 = mem[x1+0] = mem[0]
00430333,  // add x6, x6, x4    # x6 = x6 + x4 (Load-Use冒险)
0080a383,  // lw x7, 8(x1)      # x7 = mem[x1+8] = mem[8]
00c383b3,  // add x7, x7, x12   # x7 = x7 + x12 (Load-Use冒险)

// 测试用例4: 逻辑运算测试
00f3c433,  // and x8, x7, x15   # x8 = x7 & x15
0104c4b3,  // or x9, x9, x16    # x9 = x9 | x16
0115c533,  // xor x10, x11, x17 # x10 = x11 ^ x17
0126c5b3,  // and x11, x13, x18 # x11 = x13 & x18

// 测试用例5: 移位运算测试
00141413,  // slli x8, x8, 1    # x8 = x8 << 1
00249493,  // slli x9, x9, 2    # x9 = x9 << 2
00351513,  // slli x10, x10, 3  # x10 = x10 << 3
00459593,  // slli x11, x11, 4  # x11 = x11 << 4

// 测试用例6: 比较运算测试
0136c633,  // xor x12, x13, x19 # x12 = x13 ^ x19
0147c6b3,  // xor x13, x15, x20 # x13 = x15 ^ x20
0158c733,  // xor x14, x17, x21 # x14 = x17 ^ x21
0169c7b3,  // xor x15, x19, x22 # x15 = x19 ^ x22

// 测试用例7: 存储指令测试
0060a023,  // sw x6, 0(x1)      # mem[x1+0] = x6
0070a223,  // sw x7, 4(x1)      # mem[x1+4] = x7
0080a423,  // sw x8, 8(x1)      # mem[x1+8] = x8
0090a623,  // sw x9, 12(x1)     # mem[x1+12] = x9

// 测试用例8: 条件分支测试
00a0a503,  // lw x10, 10(x1)    # x10 = mem[x1+10]
00b0a583,  // lw x11, 11(x1)    # x11 = mem[x1+11]
00b50463,  // beq x10, x11, 8   # if x10 == x11, branch
00c0a603,  // lw x12, 12(x1)    # x12 = mem[x1+12]
00d0a683,  // lw x13, 13(x1)    # x13 = mem[x1+13]

// 测试用例9: 无条件跳转测试
0100006f,  // jal x0, 16        # jump to PC+16
0110006f,  // jal x0, 17        # jump to PC+17
0120006f,  // jal x0, 18        # jump to PC+18
0130006f,  // jal x0, 19        # jump to PC+19

// 测试用例10: 寄存器间跳转测试
00008067,  // jalr x0, x1, 0    # jump to x1+0
00108067,  // jalr x0, x1, 1    # jump to x1+1
00208067,  // jalr x0, x1, 2    # jump to x1+2
00308067,  // jalr x0, x1, 3    # jump to x1+3

// 测试用例11: 复杂数据冒险测试
0140a703,  // lw x14, 20(x1)    # x14 = mem[x1+20]
00e70733,  // add x14, x14, x14 # x14 = x14 + x14 (Load-Use冒险)
0150a783,  // lw x15, 21(x1)    # x15 = mem[x1+21]
00f787b3,  // add x15, x15, x15 # x15 = x15 + x15 (Load-Use冒险)

// 测试用例12: 多重转发测试
0160a803,  // lw x16, 22(x1)    # x16 = mem[x1+22]
0170a883,  // lw x17, 23(x1)    # x17 = mem[x1+23]
01088833,  // add x16, x17, x16 # x16 = x17 + x16 (需要转发)
01190833,  // add x16, x18, x17 # x16 = x18 + x17 (需要转发)

// 测试用例13: 边界条件测试
fff00093,  // addi x1, x0, -1   # x1 = -1
00100093,  // addi x1, x0, 1    # x1 = 1
00000093,  // addi x1, x0, 0    # x1 = 0
7ff00093,  // addi x1, x0, 2047 # x1 = 2047

// 测试用例14: 内存访问测试
0180a903,  // lw x18, 24(x1)    # x18 = mem[x1+24]
0190a983,  // lw x19, 25(x1)    # x19 = mem[x1+25]
01a0aa03,  // lw x20, 26(x1)    # x20 = mem[x1+26]
01b0aa83,  // lw x21, 27(x1)    # x21 = mem[x1+27]

// 测试用例15: 最终验证测试
01c0ab03,  // lw x22, 28(x1)    # x22 = mem[x1+28]
01d0ab83,  // lw x23, 29(x1)    # x23 = mem[x1+29]
01e0ac03,  // lw x24, 30(x1)    # x24 = mem[x1+30]
01f0ac83,  // lw x25, 31(x1)    # x25 = mem[x1+31]

// 测试用例16: 循环测试
0200ad03,  // lw x26, 32(x1)    # x26 = mem[x1+32]
0210ad83,  // lw x27, 33(x1)    # x27 = mem[x1+33]
0220ae03,  // lw x28, 34(x1)    # x28 = mem[x1+34]
0230ae83,  // lw x29, 35(x1)    # x29 = mem[x1+35]

// 测试用例17: 特殊指令测试
0240af03,  // lw x30, 36(x1)    # x30 = mem[x1+36]
0250af83,  // lw x31, 37(x1)    # x31 = mem[x1+37]
0260a003,  // lw x0, 38(x1)     # x0 = mem[x1+38] (应该被忽略)
0270a083,  // lw x1, 39(x1)     # x1 = mem[x1+39]

// 测试用例18: 数据依赖链测试
0280a103,  // lw x2, 40(x1)     # x2 = mem[x1+40]
00410133,  // add x2, x2, x4    # x2 = x2 + x4
00410133,  // add x2, x2, x4    # x2 = x2 + x4
00410133,  // add x2, x2, x4    # x2 = x2 + x4

// 测试用例19: 控制冒险测试
0290a183,  // lw x3, 41(x1)     # x3 = mem[x1+41]
02a0a203,  // lw x4, 42(x1)     # x4 = mem[x1+42]
02b0a283,  // lw x5, 43(x1)     # x5 = mem[x1+43]
02c0a303,  // lw x6, 44(x1)     # x6 = mem[x1+44]

// 测试用例20: 最终状态验证
02d0a383,  // lw x7, 45(x1)     # x7 = mem[x1+45]
02e0a403,  // lw x8, 46(x1)     # x8 = mem[x1+46]
02f0a483,  // lw x9, 47(x1)     # x9 = mem[x1+47]
0300a503;  // lw x10, 48(x1)    # x10 = mem[x1+48]